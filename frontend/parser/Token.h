// Copyright (c) 2014, Jeff Cohen
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/******************************************************************************/

// The token classes represent the tokens that are generated by the Jolt lexer.
// They are managed objects, so they can be freely referenced by the AST that's
// created by the parser.  Of particular interest is the Integer class, which
// implements arbitrary precision integers.

#pragma once

class Token;

#include "parser/Location.h"
#include "util/Object.h"

// Every token created by the lexer is an instance of Token.  No attempt is
// made to explicitly free tokens that have outlived their usefulness.  Garbage
// collection takes care of that.  Among other things, this allows scanning
// ahead as far as necessary to resolve ambiguities without worrying about the
// bookkeeping.
class Token: public Object {
  DECLARE_OBJECT(Token)

public:
  Token(Token *next, short lexeme, Object *value)
      : m_next(next),
        m_lexeme(lexeme),
        m_value(value) { }

  Token(Token *after, short lexeme, bool converted_nl = false)
      : m_next(after->m_next),
        m_lexeme(lexeme),
        m_line_no(after->m_line_no) {
    if (converted_nl) {
      m_col = after->m_nl_col;
      after->m_ws_after = 0;
    } else {
      // We're splitting a two character lexeme in half.
      m_col = after->m_col + 1;
      m_nl_col = after->m_nl_col;
      m_ws_after = after->m_ws_after;
      after->m_ws_after = 0;
    }
  }

  static void TokenizeFile(bool first, Token *t);

  Token              *m_next      = nullptr;
  short               m_lexeme    = 0;
  char                m_ws_after  = 0;
  bool                m_stmt_mark = false;
  uint32_t            m_line_no   = 0;
  uint32_t            m_col       = 0;
  uint32_t            m_nl_col    = 0;
  Object             *m_value     = nullptr;

  Location GetLocation();

  void CopyLocation(Token *from) {
    m_line_no = from->m_line_no;
    m_col = from->m_col;
  }

  static Token *GetNextToken();
};

namespace messageimpl {
  inline Location GetLocation(Token *t) {
    return t->GetLocation();
  }
}

// Float represents the value of a token with a floating-point value.
class Float: public Object {
  DECLARE_OBJECT(Float)

public:
  Float() = default;

  Float(double value) : m_value(value) { }

  operator double() { return m_value; }

  double              m_value       = 0;
};
